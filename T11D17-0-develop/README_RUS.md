# T11D17

![This day will help you get acquainted with structures and unions in C.](misc/rus/images/day11_door.png)


## Contents

1. [Chapter I](#chapter-i) \
 1.1. [Level 3. Room 3.](#level-3-room-3)
2. [Chapter II](#chapter-ii) \
 2.1. [List 1. MCO.](#list-1-mco) \
 2.2. [List 2. Instructions.](#list-2-instructions)
3. [Chapter III](#chapter-iii) \
 3.1. [Quest 1. The Doors.](#quest-1-the-doors) \
 3.3. [Quest 2. Polynomial.](#quest-2-polynomial) \
 3.4. [Quest 3. Stack for key.](#quest-3-stack-for-key) 
4. [Chapter IV](#chapter-iv)


# Chapter I

## Level 3. Room 3.

***LOADING Level 3… \
LOADING Room 3…***

\> *Осмотреться*

Очередная комната со столом, компьютером, лампой и без книг. Вот только в этот раз там, где должна быть одна дверь, их стало пятнадцать штук. На каждой из них висит странный электронный замок с клавиатурой. Очень подозрительно. Но хотя бы лампа есть - с ней всегда уютнее.

\> *Дернуть первую дверь*

Закрыто.

\> *Дернуть вторую дверь*

Заперто.

\> *Дернуть третью дверь*

Не поддается.

\> *Дернуть четвертую дверь*

Не-а.

\> *Для i = 5, пока i <= 15 -> Дернуть i-ую дверь и увеличить i*

Напрасно потраченное процессорное время...

\> *Осмотреться снова*

Вы замечаете, что рядом с кучей листов на столе лежит оставленная кем-то газетная вырезка. Был ли это ИИ каким-то образом или кто-то до Вас? Хотя странно было бы предположить, будто ИИ читает газеты и, тем более, делает газетные вырезки.

\> *Пробежаться глазами по вырезке*

***LOADING...***


# Chapter II

## List 1. MCO.

Листок пожелтевший и явно повидавший виды. К тому же вырезанный крайне неаккуратно. 

>Mars Climate Orbiter был запущен 11 декабря 1998 года на РН Дельта-2. Аппарат прибыл к Марсу через 9 месяцев. Mars Climate Orbiter 23 сентября 1999 года должен был выдать тормозной импульс и перейти на высокоэллиптическую орбиту с периодом 14 часов, а затем в течение двух месяцев с помощью ряда аэродинамических маневров в верхней атмосфере Марса довести орбиту до круговой. В расчетное время на высоте 193 км аппарат включил двигатели на торможение. Через 5 минут MCO запланировано ушел за Марс и больше никаких сигналов с него не поступало. Из анализа данных было предположено, что аппарат прошел над поверхностью Марса на высоте 57 км вместо расчетных 110 км и распался в атмосфере. Столь большое отклонение было вызвано ошибкой в программном обеспечении миссии: команды по тяге двигателя в программном обеспечении Mars Climate Orbiter использовали единицу измерения силы ньютон, в то время как программное обеспечение на Земле, которое создавало эти команды, использовало британскую единицу измерения (фунт-сила)...

\> *Взять первый лист из стопки под газетной вырезкой*

***LOADING...***


## List 2. Instructions.

Лист похож на вырванную страницу из какой-то книги по программированию... Вероятно, стоит внимательно прочесть.

>Структура - определенный пользователем тип, позволяющий совместно хранить и перемещать несколько значений разного типа. Определение структуры происходит следующим образом:

    struct [имя структуры] {
    определение элемента;
    определение элемента;
    …
    определение элемента;
    } [одна или несколько переменных];

>Использование структур позволяет объединять совместно используемые данные, а также оставляет возможность для дальнейшей модификации передаваемых данных без изменений заголовков функций.
>
>Объем памяти, занимаемый структурой, равен сумме занимаемой памяти всех её элементов. В связи с этим структуры в языке С являются абстракциями с нулевой стоимостью. Элементы структуры располагаются в памяти в том порядке, в котором определены.

\> *Взять следующий лист*

>Объединение - тип данных, позволяющий переиспользовать память для хранения значений различного типа. Определение объединения происходит следующим образом:

    union [имя объединения] {
    определение элемента;
    определение элемента;
    …
    определение элемента;
    } [одна или несколько переменных];

>Занимаемая объединением память определена как память, необходимая для хранения наибольшего элемента объединения.
>.....................

Далее текст нечитаем

>Одним из применений объединений и структур являются, т.н., объединения с меткой. Это структуры, позволяющие хранить в себе один из нескольких допустимых типов данных, и содержащие в себе метку - целое число, по которому можно определить, какой конкретно тип данных находится в объединении в данный момент.

\> *Взять следующий лист*

>Односвязный список - структура данных, состоящая из последовательно связанных узлов, содержащих однотипные данные. Каждый элемент списка имеет указатель на следующий элемент, последний хранит там пустой указатель (0/NULL в C). Списки имеют переменную длину, позволяют легко выполнять объединение множества списков, однако занимают больше памяти и требуют больше элементарных операций на их обход, чем массивы.

***LOADING...***


# Chapter III

## Quest 1. The Doors. 

\> *Внимательно оглядеть комнату в поисках дополнительных подсказок*

Пусто.

\> *Внимательно оглядеть стол в поисках дополнительных подсказок*

Вы замечаете небольшую оранжевую бумажку под клавиатурой. Такие бумажки часто используют как стикеры для напоминаний. 

\> *Взять и прочесть*

Вы уверены? Это может быть личным...

![day11_sticker](misc/rus/images/day11_sticker.png)

\> *Да. Раньше это никого не смущало. Да и выбора у меня немного.*

>src/dmanager_module.c - модуль управления дверьми. \
>Не трогать функцию инициализации дверей, рушится логика ядра комнаты. \
>Все двери не открывать, от этого крашится протокол передачи. \
>Для управления выделить функцию сортировки дверей по возрастанию и закрытия "открытых" дверей. 
> 
>Структура дверей: целочисленный id и числовой статус (0 - закрыто, 1 - открыто).

Выглядит как напоминалка, оставленная кем-то задолго до Вас. Стоит обратить свое внимание на этот модуль управления дверьми, это может помочь.

***== Получен Quest 1. Создать структуру дверей в src/door_struct.h. Сама структура состоит из целочисленного 
id двери и целочисленного status'а (0 - закрыто, 1 - открыто). Исправить программу src/dmanager_module.c так, 
чтобы она отсортировала проинициализированный массив дверей по возрастанию любым алгоритмом и вывела его в 
формате: "id двери, статус двери". Помимо этого для всех дверей проставить статус "закрыта". Изменять 
функцию инициализации дверей нельзя. Придерживаться структурного подхода. Программа должна собираться при 
помощи Makefile. Имя стадии - door_struct. Исполняемый файл должен располагаться в корне репозитория в папке 
build и иметь имя Quest_1. Решение будет проверяться на утечки памяти и на стилевую норму, инструкции 
как обычно - в `materials` ==***

0, 0<br/>
1, 0<br/>
2, 0<br/>
3, 0<br/>
4, 0<br/>
5, 0<br/>
6, 0<br/>
7, 0<br/>
8, 0<br/>
9, 0<br/>
10, 0<br/>
11, 0<br/>
12, 0<br/>
13, 0<br/>
14, 0<br/>

***LOADING...***


## Quest 2. Polynomial.

Итак, двери вроде бы инициализируются. Но как выйти? Для какой двери необходимо прописать статус открыт? Если сделать это для всех дверей, то судя по запискам, это может повлечь за собой какую-то катастрофу.

\> *Перевернуть бумажку*

А вот и продолжение.

>Нужная дверь изменяется каждый день. \
>Номер текущей вычисляется через полиномиальную функцию, каждый раз разной. \
>Функция выглядит как: P(x) = a*x^n + b*x^(n−1) + ... + y * x + z. \
>Путем проб и ошибок вычислено, что аргумент функции всегда один и тот же - 3. \
>Последний рабочий полином лежит в папке materials. \
>Там же есть небольшие подсказки, чтобы составить программу решения заданного полинома с использованием односвязного списка.

В одном из листов что-то говорилось про односвязный список. Стоит узнать побольше про этот список и заодно разобраться с выделением памяти под него. \
Стоит также не забыть решить последний рабочий полином из файлика и для двери под этим порядковым номером проставить статус "открыта" в массиве после его сортировки и первичного вывода.

***== Получен Quest 2. Разработать программу src/polynomial.c, которая на вход принимает строку с многочленом, 
например `-5*x^6+3*x^2-x+7`, разбивает ее на токены, из которых формирует элементы односвязного списка и 
производит необходимые вычисления. Ответ выводится в stdout. Задавать аргумент вручную не обязательно, можно 
оформить его в виде константы равной трем. Подсказка по реализации полинома 
в виде списка лежат в папке materials. Функции по работе со списком выделить отдельно. 
Так же, в папке materials, находится полином, который необходимо решить. Его ответ является 
порядковым номером для двери в уже отсортированном массиве, которой необходимо проставить 
статус открыта, в программе src/dmanager_module.c после сортировки и вывода. Программа должна 
собираться при помощи Makefile. Имя стадии - polynomial. Исполняемый файл должен располагаться
в корне репозитория в папке build и иметь имя Quest_2. Этот квест также будет проверяться на утечки памяти и стилевую норму. ==***

| Входные данные | Выходные данные |
| ------ | ------ |
| x^5-10*x^3+3*x^2+5 | 5 |
| x^1+5*x^0 | 8 |

***LOADING...***


## Quest 3. Stack for key. 

Окей, нужная дверь теперь открыта, самое время выходить.

\> *Дернуть ручку*

Заперто... \
Однако Вы замечаете, что на двери открылся небольшой экранчик. На экране большими буквами горит надпись:

> NO DYNAMIC INT STACK AND/OR STACK OPERATIONS

Вы возвращаетесь к компьютеру и размышляете, что бы это могло значить. Как жаль, что нигде больше нет вспомогательных бумажек... \
Покопавшись в своей памяти, Вы вспоминаете, что стек - это вроде как одна из разновидностей динамических структур данных, которая часто реализуется в виде списка. Видимо, для открытия двери еще требуется написать динамический стек, который в себе содержит целые числа. Для стека необходимо реализовать его стандартный интерфейс: операции заталкивания данных в стек (push) и выталкивания из него (pop). И не забыть сохранить все реализации в src/stack.c, а объявления функций и структуры в src/stack.h. Также стоит написать модульные тесты в src/stack_test.c, чтобы проверить работоспособность стека и его функций. Иначе кто знает, что может случиться, если стек будет неправильно работать..

***== Получен Quest 3. Разработать программу src/stack.c, в которой содержатся реализации функций по работе 
с динамическим стеком (init, push, pop, destroy). Объявления функций и структуры динамического стека, 
хранящего целые числа, вынести в src/stack.h. Написать модульные тесты для проверки работы функций push 
и pop стека в src/stack_test.c. Функции методов должны возвращать SUCCESS в случае успешного прохождения 
теста и FAIL - в случае ошибки. Тесты должны собираться при помощи Makefile. Имя стадии - stack_test. 
Исполняемый файл должен располагаться в корне репозитория в папке build и иметь имя Quest_3. 
Обратите внимание: этот квест будет тестироваться утилитой `cppcheck` ==***

> 
> ***Внимание! Это задание не предусматривает автотестирование***
> 

***LOADING...***


# Chapter IV

\> *Запушить последнюю задачу в репозиторий*

Вроде бы все сделано.

\> *Подойти к нужной двери*

На небольшом экранчике пусто. Видимо Ваш стек подошел для работы двери.

\> *Дернуть ручку*

Дверь поддается и Вы делаете шаг в следующую комнату.

***LOADING...***

